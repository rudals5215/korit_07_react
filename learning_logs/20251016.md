# 금일 수업 계획
1. React Form 처리
2. TypeScript
3. React 기반 RESTful API 작성(cardatabase 연동)

# Props Drilling
- GPT
**Props Drilling**은 React(또는 비슷한 컴포넌트 기반 라이브러리)에서 **상위 컴포넌트로부터 하위 컴포넌트까지 필요한 props(속성)를 중간 컴포넌트들을 거쳐서 전달하는 과정**을 의미합니다.

### 📌 Props Drilling이란?

* 컴포넌트 A가 컴포넌트 D에게 데이터를 전달해야 하는데, A → B → C → D로 여러 단계가 있을 경우, **B와 C는 그 데이터를 직접 사용하지 않더라도 props로 받아서 전달만 해야 하는 상황**이 발생합니다.
* 이 과정을 **"props를 뚫고 내려간다"**는 의미로 "Props Drilling"이라고 부릅니다.

#### 예시:

```jsx
function Parent() {
  const userName = "Alice";
  return <Child1 userName={userName} />;
}

function Child1({ userName }) {
  return <Child2 userName={userName} />;
}

function Child2({ userName }) {
  return <Child3 userName={userName} />;
}

function Child3({ userName }) {
  return <p>Hello, {userName}</p>;
}
```

* `Child3`에서만 `userName`이 필요한데 `Parent`에서 `Child3`까지 계속 전달해야 함 → 유지보수 어려워짐

---

### 😖 Props Drilling의 문제점

* **복잡성 증가**: 컴포넌트 트리가 깊어질수록 관리가 어려워짐
* **불필요한 재렌더링**: 중간 컴포넌트들이 데이터에 관심 없어도 props 변경에 따라 렌더링됨
* **재사용성 저하**: 중간 컴포넌트가 특정 데이터에 종속되면서 범용성이 낮아짐

---

### ✅ Props Drilling 해결 방법

#### 1. **React Context API** (가장 일반적인 해결책)

* 전역처럼 데이터를 공유할 수 있는 방법 제공
* 중간 컴포넌트들을 거치지 않고 원하는 하위 컴포넌트에서 데이터 사용 가능

```jsx
const UserContext = React.createContext();

function Parent() {
  return (
    <UserContext.Provider value="Alice">
      <Child1 />
    </UserContext.Provider>
  );
}

function Child3() {
  const userName = useContext(UserContext);
  return <p>Hello, {userName}</p>;
}
```

#### 2. **State Management 라이브러리 사용**

* 예: **Redux**, **Zustand**, **Recoil**, **MobX**
* 전역 상태 저장소를 활용해 필요한 컴포넌트에서 직접 접근 가능
* 특히 상태가 많고 복잡한 앱에서는 Context보다 효과적일 수 있음

#### 3. **컴포넌트 구조 재설계**

* 데이터가 필요한 컴포넌트를 상위로 올리거나 구조를 재배치
* 예를 들어, 데이터를 사용하는 컴포넌트를 위로 올려서 중간 전달을 줄이기

#### 4. **Custom Hooks 사용**

* 데이터를 처리하는 로직을 hook으로 분리하고 필요한 컴포넌트에서 사용

---

### 🧠 결론

| 방식                | 적합한 상황                    |
| ----------------- | ------------------------- |
| **Context API**   | 비교적 간단한 앱, 몇 가지 공통 데이터 공유 |
| **Redux 등 상태 관리** | 복잡하고 많은 상태 관리 필요할 때       |
| **구조 재설계**        | 단순히 컴포넌트 설계가 잘못되었을 때      |
| **Custom Hooks**  | 데이터 로직의 재사용성이 필요한 경우      |

좋은 질문이에요! Props Drilling을 해결하기 위해 자주 사용되는 **Context API**, **Recoil**, **Zustand**는 모두 **상태 관리(state management)**를 돕는 도구들이에요. 각각의 특징과 사용 목적이 다르기 때문에, 어떤 상황에서 어떤 걸 선택할지 아는 것이 중요합니다.

---

## 🎯 1. **Context API**

### ✅ 개념

* React에 내장된 상태 공유 도구 (외부 라이브러리 설치 불필요)
* 여러 컴포넌트 간에 **전역적으로 데이터를 공유**할 수 있도록 함

### ✅ 사용 목적

* 사용자 정보, 테마, 언어 설정 등 **글로벌하게 공유되어야 할 상태**에 적합

### ✅ 예시 코드

```jsx
// 1. Context 생성
const ThemeContext = React.createContext();

// 2. Provider로 상태를 공급
function App() {
  return (
    <ThemeContext.Provider value="dark">
      <Child />
    </ThemeContext.Provider>
  );
}

// 3. 하위 컴포넌트에서 useContext로 사용
function Child() {
  const theme = useContext(ThemeContext);
  return <div>현재 테마: {theme}</div>;
}
```

### ✅ 장점

* React 기본 기능 (추가 라이브러리 불필요)
* 간단하고 빠르게 적용 가능

### ❌ 단점

* 상태가 복잡해질수록 코드가 지저분해짐
* **성능 이슈**: 모든 하위 컴포넌트가 한 context를 공유하면 **모든 컴포넌트가 재렌더링**됨

---

## 🧠 2. **Recoil**

### ✅ 개념

* Facebook이 만든 React 전용 **상태 관리 라이브러리**
* 원자(atom) 단위로 상태를 나누어 관리할 수 있음

### ✅ 사용 목적

* **컴포넌트 간 상태 공유** + **세분화된 상태 관리**
* 특히 **비동기 상태, 파생 상태** 관리에 유리

### ✅ 기본 사용 예시

```jsx
// 1. 상태 정의
import { atom, useRecoilState } from 'recoil';

const countState = atom({
  key: 'countState',
  default: 0,
});

// 2. 사용
function Counter() {
  const [count, setCount] = useRecoilState(countState);
  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={() => setCount(count + 1)}>증가</button>
    </div>
  );
}

// 3. App을 RecoilRoot로 감싸야 함
import { RecoilRoot } from 'recoil';

function App() {
  return (
    <RecoilRoot>
      <Counter />
    </RecoilRoot>
  );
}
```

### ✅ 장점

* atom 단위로 상태를 분리 → **불필요한 재렌더링 방지**
* **비동기 상태 관리 지원 (selectors)**
* 기존 React 방식과 유사해서 진입장벽 낮음

### ❌ 단점

* Context API보다 **세팅 복잡**
* 대형 프로젝트에서는 상태가 많아지면 **구조 관리 필요**

---

## 🐻 3. **Zustand**

### ✅ 개념

* **Minimal, fast, and scalable** 상태 관리 라이브러리 (by Poimandres)
* Redux보다 간단하고, Recoil보다 가볍고 빠름
* **Context, Provider 불필요**

### ✅ 사용 목적

* 간단하지만 효율적인 상태 관리
* 특히 **작은/중간 규모 프로젝트**, 또는 **로직 분리**에 강점

### ✅ 기본 사용 예시

```jsx
// 1. 상태 생성
import create from 'zustand';

const useStore = create((set) => ({
  count: 0,
  increase: () => set((state) => ({ count: state.count + 1 })),
}));

// 2. 사용
function Counter() {
  const { count, increase } = useStore();
  return (
    <div>
      <p>Count: {count}</p>
      <button onClick={increase}>증가</button>
    </div>
  );
}
```

### ✅ 장점

* **Provider 없이 바로 사용 가능**
* 코드가 짧고 직관적
* 불필요한 렌더링 최소화 (선택적 구독 가능)
* TypeScript 친화적

### ❌ 단점

* 공식적인 미들웨어나 도구 생태계는 Redux보다 작음
* 사용자가 구조를 잘 설계해야 함 (명확한 상태 관리 설계 필요)

---

## 🔍 비교 정리

| 항목          | Context API | Recoil            | Zustand         |
| ----------- | ----------- | ----------------- | --------------- |
| 소속          | React 기본    | Facebook 제작       | 외부 (Poimandres) |
| 러닝 커브       | 낮음          | 보통                | 낮음              |
| Provider 필요 | ✅ 필요        | ✅ 필요 (RecoilRoot) | ❌ 불필요           |
| 상태 세분화      | ❌ 어렵다       | ✅ atom 단위로 가능     | ✅ slice처럼 사용 가능 |
| 비동기 처리      | ❌ 직접 구현 필요  | ✅ selector로 지원    | ⚠️ 직접 구현 필요     |
| 퍼포먼스 최적화    | ❌ 제한적       | ✅ 뛰어남             | ✅ 뛰어남           |
| 프로젝트 규모     | 소규모         | 중~대규모             | 소~중규모           |

---

## 🧭 어떤 걸 써야 할까?

| 상황                             | 추천 도구           |
| ------------------------------ | --------------- |
| 단순한 전역 상태 (테마, 로그인 여부 등)       | **Context API** |
| 복잡한 상태, 비동기 API, atom 단위 관리 필요 | **Recoil**      |
| 빠르고 간결한 상태 관리 원할 때             | **Zustand**     |

이외에도 `Redux`, `MobX`, `Jotai`, `React Query / TanStack Query`, `Apollo Client (GraphQL 전용)`, `Custom Hook + Local Storage / Session Storage / URL Params` 등이 있다. 

# Context API / Recoil / Zustand - Props Drilling을 해결하기 위한 방법

# React Form 처리
- HTML / CSS 수업 할 때 오렌지가 어쩌고 하면서 form 처리와 관련된 부분을 다뤘습니다. React에서는 약간 차이가 있는데, HTML 양식은 제출되면(submit이 이루어 지면), 다음 페이지로 이동합니다. React에서는 제출 후 데이터에 접근할 수 있는 JS 함수를 호출하고 다음 페이지로의 이동을 방지하고 싶은 경우가 흔히 있습니다.(SPA니까) .preventDefault()를 이용하여 제출 자체를 피하는 방법을 어제 마지막으로 다뤘습니다.

1. MyForm2.jsx 생성
2. App.jsx에 MyForm2만 배치

이후 input 하나와 button 하나가 있는 최소한의 폼을 생성하고, 입력한 field의 값을 가져오기 위해 onChange 이벤트 핸들러를 다룰 예정.

useState() 훅을 활용하여, text라는 상태 변수를 하나 생성할겁니다. 그래서 input 필드의 값이 변경되면 새 값이 상태에 _갱신_ 될 수 있도록 작성할겁니다.

이 MyForm 컴포넌트는 폼 데이터가 리액트에 의해 처리되기 때문에 _제어 컴포넌트_ 라고 불립니다.

제어되지 않는 컴포넌트에서 폼 데이터는 DOM에 의해서만 처리될겁니다.
setText(event.target.value); 문을 통해 input field에서 값을 가져와서 상태에 저장하고, 제출 버튼을 눌렀을 때 입력한 값을 alert으로 띄울겁니다.
이하는 예시입니다.
```jsx
import { useState } from "react";

function MyForm2() {
  const [text, setText] = useState('');

  // input field에 입력한 것을 submit하면 날려보낼 수 있도록 하는 함수를 작성
  const handleChange = (event) => {
    setText(event.target.value);
    console.log(text);
  }

  const handleSubmit = (event) => {
    alert(`'${text}' 라고 입력하셨습니다.`);
    event.preventDefault();
  }

  return (
    <form onSubmit={handleSubmit}>
      <input type="text" onChange={handleChange} value={text} />
      <br />
      <br />
      <input type="submit" value="클릭하세요 👾" />
    </form>
  );
}

export default MyForm2;
```
이상의 예시에서 어제 내용과 헷갈릴 수 있는데, 상태가 업데이트 된다고 해서 매번 리렌더링이 일어나는 것은 아닙니다. 상태의 변화를 감지하여 리렌더링을 일으키기 위한 Hook은 useEffect() 였습니다.

## React Developer Tools 확인 방법
F12 눌러서 Compoenets로 들어가보면 현재 작성한 코드 상에서의 Hook들을 확인 할 수 있습니다. MyForm을 기준으로 했을 때 text라는 상태 하나 밖에 없기 때문에

hooks
1.State : "안녕하세요"

를 확인할 수 있습니다.

그러면 다수의 상태를 확인하는 부분을 체크하도록 하겠습니다.
1. MyForm3.jsx 생성.
2. App.jsx에 MyForm를 import.

근데 우리가 todolist 때문에 하나짜리 input으로 작성해서 그렇지 대부분의 경우 입력 form에는 입력 field가 복수로 이루어져 있습니다. 그러면 각각의 상태를 선언하는 방법도 있겠지만, 객체를 이용하여 처리하는 방법도 있을겁니다. MyForm3에서 이를 검증하도록 하겠습니다.
이하는 예시입니다.
```jsx
import { useState } from "react";

function MyForm3() {

  const [ user, setUser] = useState({
    firstName: '',
    lastName: '',
    email: '',
  });

  // form에서 쓸 거라 handelSubmit부터 작성.
  const handleSubmit = (event) => {
    alert(`Hello, ${user.firstName} ${user.lastName}`);
    event.preventDefault();
  }

  // form 태그 썼고 내부에 input 창으로 입력을 받을거니까 onChange를 작성할 예정.
  // 그런데 여러 개의 input 태그 내에 onChange={event => setUser(event.target.value)}를 field 개수 대로 쓸 필요는 없을 것 같으니까
  const handleChange = (event) => {
    setUser({...user, [event.target.name]: event.target.value})    // 스프레드 연산자
  }

  return (
    <form onSubmit={handleSubmit}>
      <label>first Name : </label>
      <input
        type="text"
        name="firstName"
        onChange={handleChange}
        value={user.firstName}
      />
      <br />
      <label>last Name : </label>
      <input
        type="text"
        name="lastName"
        onChange={handleChange}
        value={user.lastName}
      />
      <br />
      <label>email : </label>
      <input
        type="text"
        name="email"
        onChange={handleChange}
        value={user.email}
      />
      <br />
      <input type="submit" />
    </form>
  );
}

export default MyForm3;
```

JS 객체에서 특정 value를 참조하는 방법
1. 객체명.키
  - console.log(person.firstName);
2. 객체명['키']
  - console.log(person['firstName']);

lastName과 email에 대한 부분을 완성하고 맨 마지막에 input type='submit'까지 적용해서 input 창에 firstName / lastName 입력 후에 제출 버튼을 눌러 alert을 띄우시오.

### 과제
1. MyForm4.jsx 생성
2. App3.jsx 생성 및 복사 후 App.jsx 초기화 및 MyForm4만 import
3. MyForm3를 참조하는데, 상태를 각각 선언하고, MyForm3와 동일하게 기능할 수 있도록 코드 작성
  - 즉, user 상태가 아니라, firstName / lastName / email을 별개로 상태 선언을 한 후에 코드 작성.
  - 이상의 경우, onChange에 대한 부분에서 변화가 생길 수 있습니다. 이를 염두해둔 상태로 코드 작성.

```jsx
import { useState } from "react";

function MyForm4 () {
  const [ firstName, setFirstName ] = useState('');
  const [ lastName, setLastName ] = useState('');
  const [ email, setEmail ] = useState('');

  // 잘 생각해보면 alert을 띄우는건 학습 상황이라 그렇지 실제 얘가 하는 역할은 form 태그의 preventDefault()를 쓰기 위함에 가까움.
  const handleSubmit = (event) => {
    alert(`Hello, ${firstName} ${lastName}`);
    event.preventDefault();
  };

  return (
    <form onSubmit={handleSubmit}>
      <label>first Name : </label>
      <input
        type="text"
        onChange={(event) => setFirstName(event.target.value)}
        value={firstName}
      />
      <br />
      <label>last Name : </label>
      <input
        type="text"
        onChange={(event) => setLastName(event.target.value)}
        value={lastName}
      />
      <br />
      <label>email : </label>
      <input
        type="email"
        onChange={(event) => setEmail(event.target.value)}
        value={email}
      />
      <br />
      <input type="submit" value='제출'/>
    </form>
  );
}

export default MyForm4;
```

# TypeScript
- TypeScript는 MS에서 개발한, 타입 시스템을 제공하는 JS 상위 집합에 해당합니다. 최근에 인기가 늘어나고 있는 중이고, 22년 기준으로 가장 빠르게 성장하는 프로그래밍 언어로 선정.

- 특징
1. 변수, 함수, 클래스에 대한 _자료형_ 을 정의할 수 있다. 이를 통해 개발 프로세스 초기에 오류를 포착하는 것이 가능.
2. 앱의 확장성을 향상시킬 수도 있고, 코드를 더 쉽게 유지 관리할 수 있게 해줌.
3. 코드 가독성이 향상되고 코드 자체 문서화가 더 쉽다.

타입스크립트 작성용 웹 IDE 사이트 : https://www.typescriptlang.org/play

## 공통 타입
- TS는 변수를 초기화할 때 변수의 타입을 자동으로 정의하는데, 이를 _타입 추론_ 이라고 함.

```ts
let message = '안녕하세요';     
// string 자료형이라고 TS가 타입추론을 합니다.
message = 1;
```
message에 string 값을 대입했을 때, ts는 해당 변수의 자료형이 string이라고 알아서 타입 추론을 합니다. 그런데 다음 줄에서 messate 변수에 number 자료형을 대입하니까 오류 메시지가 떴습니다.(JS에서는 상관없죠)

TS의 기본 타입은 JS와 동일합니다.
1. String : 문자열
2. number : 숫자
3. bool : boolean

그런데 TS가 매번 암시적으로 타입 추론을 하게끔 하는 것이 아니라, 명시적 타입 설정을 하는 것도 가능합니다.
- 명시적 타입 설정 방법
```ts
let email : string;
email = 3;
// 이상에서의 주목해야 할 점은 email이 number 자료형으로 초기화가 됐음에도 불구하고 오류가 떴다는 점입니다.
let page : number;
let isActive : boolean;

email = 'a@test.com';
age = 1;
// 변수의 자료형 확인
console.log(typeof email);      // 결과값 : string
console.log(typeof age === 'string');       // 결과값 : false
```
그런데 변수의 타입을 모르는 경우도 있을 수도 있습니다. 예를 들어서 외부 소스로부터 값을 받아올 때는 명확한 자료형을 모를 수도 있습니다.
```ts
let externalValue : unknown;
```
* 참조 : TS에서는 any라는 자료형도 존재합니다. any 타입을 이용하여 변수를 정의하는 경우는 TS가 해당 변수에 대해서 타입 검사 또는 추론을 아예 하지 않습니다.(즉, 기존의 JS처럼 사용이 가능합니다.) 근데 이건 TS를 사용하지 않겠다고 하는 거랑 다를 바가 없다보니까 가능한 any는 안쓰는 것을 추천.

- 배열(Array) : JS에서와 동일한 방식으로 선언할 수 있기는 한데, 배열의 element 들의 자료형을 정의해야 합니다.
```ts
let arrayOfNums: number[] = [1,2,3,4,5];
let animals: string[] = ['Dog','Cat','Tiger'];

// 제네릭 타입을 사용하는 방법
let arrayOfNums2: Array<number> = [9,8,7,6];
let animals2 : Array<string> = ['개','고양이','호랑이'];
```
- 또한 객체(Object)에서도 각각의 property에 대해 타입 추론을 알아서 합니다.
```ts
const student = {
  id : 1,
  name : '김일',
  email : 'kim1@test.com'
}
```
라고 했을 때, student.id의 자료형은 number, student.name / student.email의 자료형은 string이라고 알아서 추론을 한다는 겁니다.

그런데 이 부분도 미리 통제를 하고 싶다면, interface / type 키워드를 활용하여 객체 내부의 property의 자료형을 명시하는 것이 가능합니다.

```ts
// interface 이용 사례
interface Student {
    id : number;
    name : string;
    email : string;
}
// 이거 또 JS처럼 생겼기 때문에 (,) 써서 오류내는 사람이 많습니다.
// type 이용 사례
type Student2 =  {
    id : number;
    name : string;
    email : string;
}
// 이상과 같이 Student에 대한 속성에 대한 자료형이 있다고 가정했을 때, 이를 다 모아둔 Student를 자료형으로 또 쓸 수 있습니다.

const myStudent: Student = {
    id : 1,
    name : '김일',
    email : 'kim1@test.com'
};
// id: '1', 로 쓰면 오류 발생

// DTO에서 프론트엔드로 넘어올 때 자료형을 강제시킬 수 있다.
```
그리고 Java에서의 와일드카드에 해당하는 `?`도 있습니다. 선택적 속성을 정의할 수 있는데, 이는 일종의 생성자 부분과 관련이 있다고 볼 수 있습니다.

```ts
type Student =  {
    id : number;
    name : string;
    email : string;
}

const myStudent: Student = {
    id : 1,
    name : '김일',
    email : 'kim1@test.com'
};

// 오류 발생
const myStudent: Student2 = {
    id : 1,
    name : '김일',
};

// 해결 방법 `?`를 사용
type Student1 =  {
    id : number;
    name : string;
    email? : string;
}

const myStudent1: Student1 = {
    id : 1,
    name : '김일',
};

console.log(myStudent1.email);       // 결과값 : undefined
```
- 선택자 체이닝 연산자(?.)를 이용하면 오류를 일으키지 않고 null이거나 undefined일 수 있는 객체 속성 및 메서드에 안전하게 접근이 가능.

```ts
// type 정의
type Person = {
  name : string,
  email : string,
  address? : {
    street : string,
    city : string,
  }
}
// 객체 생성
const person : Person = {
    name : '김이',
    email: 'kim2@test.com'
}

console.log(person);
// 오류가 생기는 부분
console.log(person.address.street);
// 선책적 체이닝을 통해 오류 발생 자체를 억제할 수 있습니다.
console.log(person.address?.street);
```
이상의 결과값으로는 undefined가 출력되고, 오류는 발생하지 않는다.

그럼 이상까지의 상황에서 TS를 적용했을 때의 이점은 기본적으로 JS 상에서는 _실행을 시키고 나서야 오류 유무를 확인_ 할 수 있는 반면, TS 상에서는 개발 단계에서(즉, 테스트 / 실전 데이터 입력 이전 단계에서) 예측 가능한 오류를 발생시키지 않을 수 있다는 점입니다.

- 연산자를 이용한 서로 다른 타입을 병렬로 명시하는 방법
```ts
type InputType = string | number;
// 정의한 타입을 이용
let name1 : InputType = 'Hello';
let age : InputType = 12;
```
```ts
type Fuel = 'disel' | 'gasoline' | 'electric';
type NoOfGears = 5 | 6 | 7;

type Car = {
    brand : string;
    fuel : Fuel;
    gears : NoOfGears;
};

const car1 : Car = {
    brand : '기아',
    fuel : 'disel',
    gears : 5
}

const car2 : Car = {
    brand : '기아',
    fuel : 'disell',  // 오타가 나거나 Fuel 내에 있는 string data를 벗어나면 오류
    gears : 5         // 마찬가지로 5,6,7이 아닌 다른 숫자가 들어가도 오류
}
```
이상의 예시는 연산자를 이용하여 _서로 다른 타입을 처리하는 타입_ 인 유니언 타입(Union Type)을 만드는 것이 가능합니다.

첫 번째 예시의 경우에는 string 이거나 number일 수 있는 InputType이라는 유니언 타입을 생성했고,
두 번째 예시는 특정 string data(disel, gasoline, electric)이거나 특정 number data(5,6,7)만을 가질 수 있는 유니언 타입인 Fuel / NoOfGears를 생성했습니다.

일종의 사용자 정의 type이라고 볼 수 있겠습니다. Java에서 저희가 class를 정의했던 것처럼.

## 함수
```ts
function sayHello(name : string) {
  console.log('hello ' + name);
}

sayHello(1);
// 근데 name이 꼭 string이어야 하냐 number일 수도 있지않나
```
- number도 가능하게 하는 방법
```ts
function sayHello(name : string | number) {
  console.log('hello ' + name);
}

sayHello(1);
sayHello('김일');
```
이상의 경우에서는 매개변수의 자료형을 고정시키거나 혹은 복수의 자료형 중에 하나를 선택할 수 있게끔 통제하는 방안을 학습했습니다.

이하에서는 return 타입에 대한 자료형 통제 부분입니다.
```ts
function clacSum(x:number, y:number) : number {
  return x + y;
}

// 불가능 (x,y가 전부 같은 자료형이어야 함)
function clacSum(x:number | string, y:number | string) : number | string {
  return x + y;
}
```
여기까지가 TS의 기초 파트

## TypeScript in React
### 상태와 프롭
- 리액트에서는 컴포넌트 프롭의 타입을 정의해야 합니다. 컴포넌트의 프롭이 JS 객체라고 학습했었습니다. 그래서 props.username과 같은 방식으로 호출했었죠. 그러면 프롭의 타입을 정의하기 위해서는 type 또는 interface를 사용하는 것이 가능할겁니다.

1. HelloComponent.tsx 생성
2. App.tsx의 내용을 App2.tsx로 복사, App.tsx 초기화
3. HelloComponent를 App.tsx에 import
4. npm run dev를 통해서 빈 화면을 브라우저에 출력

```tsx
type HelloProps = {
  name: string;
  age: number;
}

function HelloComponent ({name, age} : HelloProps) {   // 객체 구조분해 part 참조
  return (
    <>
      Hello, {name}, you are {age} years old!
    </>
  )
}

export default HelloComponent;
```

이상의 코드를 해석하기 위해 알아야 하는 개념
1. 객체 구조 분해
2. props drilling
3. props가 JS의 객체라는 점
4. typescript 상에서의 매개변수에 자료형을 통제하는 방법

이상의 코드를 적용하게 되면 age='20'과 같은 방식으로 프롭을 전달하게 됐을 때 오류 메시지를 출력합니다. jsx의 경우 오류 메시지 자체가 나타나지 않습니다. 그럼 이 오류가 드러나는 시점은 age='20'이라는 string data를 가지고 수학 연산을 시도했을 시점이 되어야 오류를 확인할 수 있게 된다는 점 입니다.

하지만 TS를 사용했을 경우 미리 경고 메시지를 보내주기 때문에 연산 이전에 수정을 할 수 있다는 점에서 도입할만한 가치가 있다고 할 수 있겠습니다.

```tsx
import HelloProps from "./types/type";

function HelloComponent ({name, age} : HelloProps) {   // 객체 구조분해 part 참조
  return (
    <>
      Hello, {name}, you are {age} years old!
    </>
  )
}

export default HelloComponent;
```
이상은 이미 정의한 type을 types/types.ts로 분할하여 import한 예시 입니다.
이상과 같이 했을 경우, 만약에 ByeComponent를 만든다고 가정했을 때, 거기서도 똑같이 HelloProps를 쓸 수 있겠죠.

ByeComponent를 확인하세요.

근데 이 타입 추론이라는 개념이 꼭 TS에서만 사용되는 것이 아니고 표준 리액트 타입인 FC(Function Component)가 있긴 합니다.

예시만 보여주고 넘어가겠습니다.
```jsx
import React from 'react';
import {HelloPorps} from './types/types';

const HelloComponent : React.FC<HelloProps> = ({name, age} => {
  return (
    <>
      Hello, {name}, you are {age} years old!
    </>
  );
})
```
이상까지는 props의 자료형을 통제하는 방식을 학습했습니다.

```jsx
// boolean
const [isReady, setIsReady ] = useState(false);

// string
cons [ message, setMessage] = useState('');

// number
const [ count, setCount ] = useState(0);
```
이상의 배웠었던 useState 훅을 생각해보면 initialValue 값을 _타입 추론_ 한다는 것을 알 수 있습니다.
그래서 
```jsx
setCount('Hello');
```
와 같은 방식으로 암시적으로 작성된 type과 다른 자료형을 argument로 넣을 경우 오류가 발생합니다.
그런데 TS는 명시적으로 타입을 설정하는 편이기 때문에 useState()의 initialValue의 자료형을 통제하는 것이 가능합니다.
```tsx
const [ message, setMessage ] = useState<string | undefined>(undefined);
```
이상의 예시는 message의 자료형이 string이거나 undefined로 넣어줄 수 있습니다.

혹은, 아까 배운 방식대로, type / interface를 사용하는 방법도 있습니다.
```ts
// types.ts
type User = {
  id: number;
  name: string;
  email: string;
}
```
```tsx
import { User } from './types/types';
import { useState } from 'react';

function ExampleComponent() {
  // 타입을 상태와 함께 활용하고자 할 때 초기값으로는 아무것도 담겨있지 않은 User 객체를 이용
  const [ user, setUser ] = userState<User>({} as User);
  // 혹은 null 값도 허용됩니다.
  const [ user, setUser ] = useState<User | null>(null);

  return(<></>);
}
export default ExampleComponent
```
### 이벤트
onChange라는 이벤트 핸들러 관련한 학습을 어제 했습니다. TS를 이용할 때는 이벤트 타입을 세분화할 필요가 있습니다.
```tsx
<input
  type='text'
  onChange={handChange}
  value={name}
>
```
과 같이 정의되어있을 때, handleChange의 예시는 이하와 같습니다.

```tsx
const handleChange = (event) => {
  setName(event.target.value)
}
```
근데 이게 좀 난해한게, handleSubmit 때도 매개변수를 event라고 정해줬습니다.

event가 특정한 HTML element와 관련이 있다는 점을 명시할 때 사용하는 명령어가 있는데,
```tsx
const handleChange = (event: React.ChangeEvent<HTMLInputElement>) => {
  setName(event.target.value);
}
```
그렇다면 form과 관련있는 onSubmit 이벤트 핸들러의 경우에는 어떻게 되냐면
```tsx
const handleChange = (event: React.ChangeEvent<HTMLInputElement>) => {
  event.preventDefault();
  alert(`Hello ${name}`);
}
```
과 같은 방식으로 작성합니다. 즉 저희가 임의적으로 e 혹은 event로 매개변수 명을 짓기는 하지만, 어느 HTML 요소와 관련있는지에 따라 딸려있는 속성(특징)과 메서드가 서로 다르기 때문에, TS 상에서는 이를 통제하는 편입니다.

전체 종류는
chrome -> typescript cheat sheets를 검색하면
https://github.com/typescript-cheatsheets/react-typescript-cheatsheet-kr
참조하면 된다.

## TS로 리액트 앱 만들기
위에서 작성한 예시 코드들을 적용한 tsx를 작성.