# Shoppinglist backend 설정git
1. https://start.spring.io/ 에서 기본 설정(Spring Web, Spring Data JPA, Spring Boot DevTools, MariaDB Driver, Lombok, Rest Repositories)
2. gradle, properties 설정
* build.gradle
```js
implementation 'org.springframework.boot:spring-boot-starter-data-jpa'
implementation 'org.springframework.boot:spring-boot-starter-data-rest'
implementation 'org.springframework.boot:spring-boot-starter-web'
compileOnly 'org.projectlombok:lombok'
developmentOnly 'org.springframework.boot:spring-boot-devtools'
runtimeOnly 'org.mariadb.jdbc:mariadb-java-client'
annotationProcessor 'org.projectlombok:lombok'
testImplementation 'org.springframework.boot:spring-boot-starter-test'
testRuntimeOnly 'org.junit.platform:junit-platform-launcher'
```
* application.properties
```js
spring.datasource.url=jdbc:mariadb://localhost:3310/shoppinglist2db
spring.datasource.username=root
spring.datasource.password=1234
spring.datasource.driver-class-name=org.mariadb.jdbc.Driver

spring.jpa.generate-ddl=true
spring.jpa.hibernate.ddl-auto=create-drop

spring.data.rest.basePath=/api
```
3. Heidi SQL에서 db 생성
4. domain 패키지 생성 및 user, userRepository 생성 및 설정
* user
```js
@Entity
@Data
@NoArgsConstructor
@AllArgsConstructor
@Table(name="users")
public class User {
    @Id
    @GeneratedValue(strategy = GenerationType.AUTO)
    @Column(nullable = false, updatable = false)
    private Long id;

    @Column(nullable = false, updatable = true)
    private String username;

    @Column(nullable = false)
    @JsonIgnore     // 비밀번호가 API 응답에 노출되지 않도록 설정. 암호화할것이기 때문에
    private String password;

    @Column(nullable = false)
    private String role;

    // 한 명의 유저는 여러 개의 쇼핑 아이템을 가짐.
    @OneToMany(mappedBy = "user", cascade = CascadeType.ALL, orphanRemoval = true)
    @JsonIgnore     // car에서처럼 순환참조를 일으키지 않도록 설정.
    private List<ShoppingItem> items;

    // CommandLineRunner 상에서 사용한 간단한 생성자 정의
    public User(String username, String password, String role){
        this.username = username;
        this.password = password;
        this.role = role;
    }
}
```
* userRepository
```js
@RepositoryRestResource(exported = false)
public interface UserRepository extends JpaRepository<User, Long> {

    // UserDetailsService 에서 사용할 수 있도록 미리 추상 메서드 정의.
    Optional<User> findByUsername(String username);
}
```
5. domain 패키지에 Item, ItemRepository 생성 및 설정
* Item
```js
@Entity
@Data
@NoArgsConstructor
@AllArgsConstructor
public class ShoppingItem {

    @Id
    @GeneratedValue(strategy = GenerationType.AUTO)
    private Long id;

    private String product;
    private String amount;
    private boolean purchased = false;

    // 여러 개의 아이템이 한 명의 유저에게 속함.
    @ManyToOne
    @JoinColumn(name="user_id")
    @JsonIgnore
    private User user;

    // CommandLineRunner 상에서 사용할 간단한 생성자 정의

    public ShoppingItem(String product, String amount, boolean purchased, User user) {
        this.product = product;
        this.amount = amount;
        this.purchased = purchased;
        this.user = user;
    }
}
```
* ItemRepository
```js
@RepositoryRestResource(exported = false)
public interface ShoppingItemRepository extends JpaRepository<ShoppingItem, Long> {
  // 사용자 정의 컨트롤러에서 사용
    List<ShoppingItem> findByUser(User user);

    // 삭제 / 수정 시 authentication 확인용
    Optional<ShoppingItem> findByIdAndUser(Long id, User user);
}
```
6. Shoppinglist2Application 설정
```js
@SpringBootApplication
@RequiredArgsConstructor
public class Shoppinglist2Application implements CommandLineRunner {

	private final UserRepository userRepository;
	private final ShoppingItemRepository shoppingItemRepository;
	private final PasswordEncoder passwordEncoder;

	public static void main(String[] args) {
		SpringApplication.run(Shoppinglist2Application.class, args);
	}

	@Override
	public void run(String... args) throws Exception {
		// 테스트 사용자 생성
		User user = new User("user", passwordEncoder.encode( "user"),"USER");
		userRepository.save(user);

		User admin = new User("admin",passwordEncoder.encode( "admin"),"ADMIN");
		userRepository.save(admin);

		// user 쇼핑 아이템 더미 데이터 추가
		shoppingItemRepository.save(new ShoppingItem("우유","1개",false, user));
		shoppingItemRepository.save(new ShoppingItem("빵","1봉지",true, user));

		// admin 쇼핑 아이템 데이터 추가
		shoppingItemRepository.save(new ShoppingItem("사과","3개",false,admin));

	}
}
```
7. Heidi SQL에서 데이터 들어왔는지 확인.
8. build.gradle, properties에 OpenAPI, spring security 설정
* build.gradle
```js
//OpenAPI 명세서 관련 의존성
	implementation 'org.springdoc:springdoc-openapi-starter-webmvc-ui:2.8.13'

	// Spring Sercurity 관련 의존성
	implementation 'org.springframework.boot:spring-boot-starter-security'
	testImplementation 'org.springframework.boot:spring-boot-starter-security'
```
* properties
```js
spring.jpa.show-sql=true

springdoc.swagger-ui.enabled=true
springdoc.swagger-ui.path=/swagger-ui.html
springdoc.api-docs.path=/api-docs
```
설정 후 localhost:8080에 `Using generated security password` 이용하여 로그인 하면 White label Error 나오는데 정상. localhost:8080/api 했을 시 페이지가 나옴 (별도의 설정을 하지 않고 /api에 정보를 모아놨기 때문)
9. security 패키지 및 securityConfig, UserDetailsServiceImpl, JwtService, JwtAuthenticationFilter, AuthEntryPoint 클래스 생성, 설정
* UserDetailsServiceImpl
```js
@Service
@RequiredArgsConstructor
public class UserDetailsServiceImpl implements UserDetailsService {
    private final UserRepository userRepository;

    @Override
    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
        Optional<User> user = userRepository.findByUsername(username);

        UserBuilder builder;
        if (user.isPresent()) {
            User currentUser = user.get();
            builder = withUsername(username);
            builder.password(currentUser.getPassword());
            builder.roles(currentUser.getRole());
        } else {
            throw new UsernameNotFoundException("사용자를 찾을 수 없습니다.");
        }
        return builder.build();
    }
}
```
* JwtService
```js
@Component
public class JwtService {
    static final long EXPIRATION_TIME = 86400000;
    static final String PREFIX = "Bearer ";

    // cardatabase에서 deprecated로 떠서 이렇게 수정했습니다.
    private final SecretKey key = Jwts.SIG.HS256.key().build();

    // JWT 생성
    public String generatedToken(String username) {
        String jwt = Jwts.builder()
                .subject(username)
                .expiration(new Date(System.currentTimeMillis() + EXPIRATION_TIME))
                .signWith(key)
                .compact();
        return jwt;
    }

    // 요청 헤더에서 JWT를 파싱하여 사용자 이름(subject) 추출
    public  String getAuthUser(HttpServletRequest request) {
        String token = request.getHeader(HttpHeaders.AUTHORIZATION);

        if (token != null && token.startsWith(PREFIX)){
            try {
                String user = Jwts.parser()
                        .verifyWith(key)    // 비밀 키로 검증
                        .build()
                        .parseSignedClaims(token.replace(PREFIX,""))    // 접두사 "Bearer " 제거
                        .getPayload()
                        .getSubject();

                if (user != null) {
                    return user;
                }
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
        return null; // getAuthUser 메서드 호출했는데 user 안튀어나올 때 null return : 토큰이 없거나 유효하지 않음
    }
}
```
* JwtAuthenticationFilter
```js
@RequiredArgsConstructor
public class JwtAuthenticationFilter extends OncePerRequestFilter {

    private final JwtService jwtService;
    private final UserDetailsServiceImpl userDetailsService;

    @Override
    protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws ServletException, IOException {
        // header에서 사용자 이름(username)을 추출
        String username = jwtService.getAuthUser(request);

        // 사용자가 존재하고, Spring Security Context에 인증 정보가 없다면
        if (username != null && SecurityContextHolder.getContext().getAuthentication() == null){
            // DB에서 user 정보 조회
            UserDetails userDetails = userDetailsService.loadUserByUsername(username);

            // 토큰이 유효하면 인증 토큰을 생성하여 SecurityContext에 등록
            // 생각해보면 getAuthUser()에 검증이 끝났음.
            UsernamePasswordAuthenticationToken authentication =
                    new UsernamePasswordAuthenticationToken(userDetails, null, userDetails.getAuthorities());

            authentication.setDetails(new WebAuthenticationDetailsSource().buildDetails(request));
            SecurityContextHolder.getContext().setAuthentication(authentication);
        }
        filterChain.doFilter(request, response);
    }
}
```
* AuthEntryPoint
```js
@Component
public class AuthEntryPoint implements AuthenticationEntryPoint {
    // 인증되지 않은 사용자가 보호된 리소스에 접근하려 할 때 호출됨.(404 -> 401로 바꾸는 역할)
    @Override
    public void commence(HttpServletRequest request, HttpServletResponse response, AuthenticationException authException) throws IOException, ServletException {
        // 401 응답하기 위해서 커스텀
        response.setStatus(HttpServletResponse.SC_UNAUTHORIZED);
        response.setContentType("application/json");
        response.getWriter().write("{\"error\" : \"Unauthorized - please Log In \"}");
    }
}
```
* securityConfig
```js
@Configuration
@EnableWebSecurity
@RequiredArgsConstructor
public class SecurityConfig {

    private final UserDetailsServiceImpl userDetailsService;
    private final JwtService jwtService;
    private final AuthEntryPoint authEntryPoint;

    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }

    @Bean
    public AuthenticationManager authenticationManager(AuthenticationConfiguration config) throws Exception{
        return config.getAuthenticationManager();
    }

    @Bean
    public JwtAuthenticationFilter authenticationFilter() {
        return new JwtAuthenticationFilter(jwtService, userDetailsService);
    }

    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception{
        http.csrf(AbstractHttpConfigurer::disable)  // CSRF 보호 비활성화(Stateless JWT 사용)
                .cors(Customizer.withDefaults())    // CORS 설정(이하의 설정 사용)
                .sessionManagement(session -> session.sessionCreationPolicy(SessionCreationPolicy.STATELESS))   // 세션 비활성화
                .authorizeHttpRequests(auth -> auth
                        // /login 엔드호인트의 POST 요청은 모두 허용
                        .requestMatchers(HttpMethod.POST, "/login").permitAll()
                        .requestMatchers("/swagger-ui/**","/api-docs/**").permitAll()
                        .anyRequest().authenticated())
                .exceptionHandling(ex -> ex.authenticationEntryPoint(authEntryPoint))   // 인증 실패시 처리
                .addFilterBefore(authenticationFilter(), UsernamePasswordAuthenticationFilter.class);   // JWT 필터 추가
        return http.build();
    }

    @Bean
    public CorsConfigurationSource corsConfigurationSource() {
        CorsConfiguration configuration = new CorsConfiguration();
        configuration.setAllowedOrigins(Arrays.asList("http://localhost:5173","http://localhost:5174"));    // FE 서버 주소
        configuration.setAllowedMethods(Arrays.asList("GET","POST","PULL","DELETE","PATCH"));
        configuration.setAllowedHeaders(Arrays.asList("*"));    // 모든 헤더 허용
        configuration.setAllowCredentials(true);
        UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();
        source.registerCorsConfiguration("/**", configuration);
        return source;
    }
}
```
10. build.gradle에 jjwt 관련 설정 추가
```js
// jjwt 관련 설정
implementation 'io.jsonwebtoken:jjwt-api:0.13.0'
runtimeOnly 'io.jsonwebtoken:jjwt-impl:0.13.0'
runtimeOnly 'io.jsonwebtoken:jjwt-jackson:0.13.0'
```
11. web 패키지 생성, LoginController 패키지, AccountCredentials 레코드 생성 및 설정
* LoginController
```js
@RestController
@RequiredArgsConstructor
public class LoginController {

    private final JwtService jwtService;
    private final AuthenticationManager authenticationManager;

    @PostMapping("/login")
    public ResponseEntity<?> login(@RequestBody AccountCredentials credentials){
        // 자격 증명으로 인증 토큰 생성하는 과정
        UsernamePasswordAuthenticationToken creds = new UsernamePasswordAuthenticationToken(credentials.username(), credentials.password());

        // 사용자 인증
        Authentication auth = authenticationManager.authenticate(creds);

        // JWT 생성
        String jwt = jwtService.generatedToken(auth.getName());

        // JWT를 'Authorization' 헤더에 담아서 응답
        return ResponseEntity.ok()
                .header(HttpHeaders.AUTHORIZATION, "Bearer ", jwt)
                .header(HttpHeaders.ACCESS_CONTROL_EXPOSE_HEADERS, "Authorization")     // Frontend 에서 헤더를 읽을 수 있도록 설정
                .build();
    }
}
```
* AccountCredentials
```js
public record AccountCredentials (String username, String password){}
```

12. build.gradle, properties, securityConfig에 OAuth2 관련 설정
* build.gradle
```js
	// Google OAuth2 관련 의존성
	implementation 'org.springframework.boot:spring-boot-starter-oauth2-client'
	implementation 'org.springframework.boot:spring-boot-starter-oauth2-resource-server'
```
* properties
```js
// Google OAuth2 클라이언트 설정
spring.security.oauth2.client.registration.google.client-id=YOUR_GOOGLE_CLIENT_ID
spring.security.oauth2.client.registration.google.client-secret=YOUR_SECRET_KEY
spring.security.oauth2.client.registration.google.client-scope=openid, profile, email

// OAuth2 성골 후 redirect 될 프론트엔드 URL
oauth2.success.redirect-url=http://localhost:5173/login/oauth2/redirect
```
* securityConfig
```js
@Configuration
@EnableWebSecurity
@RequiredArgsConstructor
public class SecurityConfig {

    private final UserDetailsServiceImpl userDetailsService;
    private final JwtService jwtService;
    private final AuthEntryPoint authEntryPoint;
    private final CustomOAuth2SuccessHandler customOAuth2SuccessHandler;

    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }

    @Bean
    public AuthenticationManager authenticationManager(AuthenticationConfiguration config) throws Exception{
        return config.getAuthenticationManager();
    }

    @Bean
    public JwtAuthenticationFilter authenticationFilter() {
        return new JwtAuthenticationFilter(jwtService, userDetailsService);
    }

    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception{
//        http.csrf(csrf -> csrf.disable())
//                .cors(withDefaults())
//                .authorizeHttpRequests(authorizeHttpRequests ->
//                        authorizeHttpRequests.anyRequest().permitAll());


        http.csrf(AbstractHttpConfigurer::disable)  // CSRF 보호 비활성화(Stateless JWT 사용)
                .cors(Customizer.withDefaults())    // CORS 설정(이하의 설정 사용)
                .sessionManagement(session -> session.sessionCreationPolicy(SessionCreationPolicy.STATELESS))   // 세션 비활성화
                .authorizeHttpRequests(auth -> auth
                        // /login 엔드포인트의 POST 요청은 모두 허용
                        .requestMatchers(HttpMethod.POST, "/login").permitAll()
                        .requestMatchers("/swagger-ui/**","/api-docs/**").permitAll()
                        .requestMatchers("/oauth2/**","/login/oauth2/code/*").permitAll()
                        .anyRequest().authenticated())
                .oauth2Login(oauth2 -> oauth2.successHandler(customOAuth2SuccessHandler))
                .exceptionHandling(ex -> ex.authenticationEntryPoint(authEntryPoint))   // 인증 실패시 처리
                .addFilterBefore(authenticationFilter(), UsernamePasswordAuthenticationFilter.class);   // JWT 필터 추가
        return http.build();
    }

    @Bean
    public CorsConfigurationSource corsConfigurationSource() {
        CorsConfiguration configuration = new CorsConfiguration();
        configuration.setAllowedOrigins(Arrays.asList("http://localhost:5173","http://localhost:5174"));    // FE 서버 주소
        configuration.setAllowedMethods(Arrays.asList("GET","POST","PULL","DELETE","PATCH"));
        configuration.setAllowedHeaders(Arrays.asList("*"));        // 모든 헤더 허용
        configuration.setAllowCredentials(true);
        UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();
        source.registerCorsConfiguration("/**", configuration);
        return source;
    }
}
```
